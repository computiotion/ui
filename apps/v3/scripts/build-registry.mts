import { exec } from "child_process"
import { existsSync, promises as fs } from "fs"
import path from "path"
import { registry } from "@/registry"
import { rimraf } from "rimraf"
import { registryItemTypeSchema } from "shadcn/registry"
import { z } from "zod"

import { registryCategories } from "@/www/registry/registry-categories"
import { styles } from "@/www/registry/registry-styles"

const REGISTRY_INDEX_WHITELIST: z.infer<typeof registryItemTypeSchema>[] = [
  "registry:ui",
  "registry:lib",
  "registry:hook",
  "registry:theme",
  "registry:block",
  "registry:example",
  "registry:internal",
]

async function syncStyles() {
  // We use new-york as the source of truth.
  // We sync the files to default.
  const sourceStyle = "new-york"
  const targetStyle = "default"

  const syncDirectories = ["blocks", "hooks", "internal", "lib", "charts"]

  // Clean up sync directories.
  for (const dir of syncDirectories) {
    rimraf.sync(path.join("registry", targetStyle, dir))
  }

  for (const item of registry.items) {
    if (
      !REGISTRY_INDEX_WHITELIST.includes(item.type) &&
      item.type !== "registry:ui"
    ) {
      continue
    }

    const resolveFiles = item.files?.map(
      (file) =>
        `registry/${sourceStyle}/${typeof file === "string" ? file : file.path}`
    )
    if (!resolveFiles) {
      continue
    }

    // Copy files to target style if they don't exist.
    for (const file of resolveFiles) {
      const sourcePath = path.join(process.cwd(), file)
      const targetPath = path.join(
        process.cwd(),
        file.replace(sourceStyle, targetStyle)
      )

      if (!existsSync(targetPath)) {
        // Create directory if it doesn't exist.
        await fs.mkdir(path.dirname(targetPath), { recursive: true })
        await fs.copyFile(sourcePath, targetPath)

        // Replace all @/registry/new-york/ with @/registry/default/.
        const content = await fs.readFile(targetPath, "utf8")
        const fixedContent = content.replace(
          new RegExp(`@/registry/${sourceStyle}/`, "g"),
          `@/registry/${targetStyle}/`
        )
        await fs.writeFile(targetPath, fixedContent, "utf8")
      }
    }
  }
}

async function buildRegistryIndex() {
  let index = `// @ts-nocheck
  // This file is autogenerated by scripts/build-registry.ts
  // Do not edit this file directly.
  import * as React from "react"

  export const Index: Record<string, any> = {
  `

  for (const style of styles) {
    index += `  "${style.name}": {`

    // Build style index.
    for (const item of registry.items) {
      const resolveFiles = item.files?.map(
        (file) =>
          `registry/${style.name}/${
            typeof file === "string" ? file : file.path
          }`
      )
      if (!resolveFiles) {
        continue
      }

      // Validate categories.
      if (item.categories) {
        const invalidCategories = item.categories.filter(
          (category) => !registryCategories.some((c) => c.slug === category)
        )

        if (invalidCategories.length > 0) {
          console.error(
            `${item.name} has invalid categories: ${invalidCategories}`
          )
          process.exit(1)
        }
      }

      let componentPath = item.files
        ? `@/registry/${style.name}/${item.files[0].path}`
        : ""

      index += `
      "${item.name}": {
        name: "${item.name}",
        description: "${item.description ?? ""}",
        type: "${item.type}",
        registryDependencies: ${JSON.stringify(item.registryDependencies)},
        files: [${item.files?.map((file) => {
          const filePath = `registry/${style.name}/${
            typeof file === "string" ? file : file.path
          }`
          const resolvedFilePath = path.resolve(filePath)
          return typeof file === "string"
            ? `"${resolvedFilePath}"`
            : `{
          path: "${filePath}",
          type: "${file.type}",
          target: "${file.target ?? ""}"
        }`
        })}],
        categories: ${JSON.stringify(item.categories)},
        component: React.lazy(() => import("${componentPath}")),
        meta: ${JSON.stringify(item.meta)},
      },`
    }

    index += `
    },`
  }

  index += `
  }
  `

  // Write style index.
  rimraf.sync(path.join(process.cwd(), "registry/__index__.tsx"))
  await fs.writeFile(path.join(process.cwd(), "registry/__index__.tsx"), index)
}

async function buildRegistryJsonFiles() {
  for (const style of styles) {
    // 1. Fix the path for registry items.
    const fixedRegistry = {
      ...registry,
      items: registry.items.map((item) => {
        const files = item.files?.map((file) => {
          return {
            ...file,
            path: `registry/${style.name}/${file.path}`,
          }
        })

        return {
          ...item,
          files,
        }
      }),
    }

    // 2. Write the content of the registry to `registry.json`
    rimraf.sync(
      path.join(process.cwd(), `registry/${style.name}/registry.json`)
    )
    await fs.writeFile(
      path.join(process.cwd(), `registry/${style.name}/registry.json`),
      JSON.stringify(fixedRegistry, null, 2)
    )
  }
}

async function buildRegistry() {
  for (const style of styles) {
    exec(
      `pnpm dlx shadcn build ./registry/${style.name}/registry.json --output ../www/public/v3/styles/${style.name}`
    )
  }
}

try {
  console.log("üîÑ Syncing styles...")
  await syncStyles()

  console.log("üóÇÔ∏è Building registry/__index__.tsx...")
  await buildRegistryIndex()

  console.log("üíÖ Building registry/[style]/registry.json...")
  await buildRegistryJsonFiles()

  console.log("üèóÔ∏è Building registry...")
  await buildRegistry()
} catch (error) {
  console.error(error)
  process.exit(1)
}
